Based on GOOD PARAMETERS AND IMPLEMENTATIONS FOR COMBINED MULTIPLE RECURSIVE RANDOM NUMBER GENERATORS
# Theoretical background
Our aim is to imitate a sequence of i.i.d. $U(0, 1)$ (independent and identically distributed random variables, uniform over the interval $[0, 1]$), the set $T_t = \{\mathbf{u_n} = (u_n,\cdots, u_{n+t-1}), n\geq 0\}$, of all vectors of $t$ successive output values over all the generator’s cycles, should be uniformly distributed over the $t$-dimensional unit hypercube $[0, 1]^t$, for all $t$ (ideally).
## Linear Congruential Generators
The linear congruential generator is proposed by Lehmer which is specified with non-negative integers $\eta$, $a$, and $c$. An integer seed value $z^{[0]}$ is selected, $0 \leq z^{[0]} < \eta$, and a sequence of integers $z^{[k]}$ is obtained recursively with the formula
\begin{equation}
    z^{[k]} = a z^{[k-1]}+c(mod\ \eta)
\end{equation}
The modular notation “mod” indicates that z[k] is the remainder after dividing the quantity $az^{[k–1]} + c$ by $\eta$. A sequence of pseudo-random numbers $u^{[k]}$ is obtained by dividing the $z^{[k]}$ by $\eta$:
\begin{equation}
    u^{[k]}=z^{[k]}/\eta
\end{equation}
Consider the simplistic generator
$$
z^{[k]}=3 z^{[k-1]}+1(\bmod 7)
$$
Starting with a seed $z^{[0]}=4$, we calculate a sequence of pseudo-random numbers.
\begin{center}
\begin{tabular}{cccc}
\hline$k$ & $a z^{[k-1]}+c$ & $z^{[k]}$ & $u^{[k]}$ \\
\hline 0 & & 4 & $0.57142857$ \\
1 & 13 & 6 & $0.85714286$ \\
2 & 19 & 5 & $0.71428571$ \\
3 & 16 & 2 & $0.28571429$ \\
4 & 7 & 0 & $0.00000000$ \\
5 & 1 & 1 & $0.14285714$ \\
6 & 4 & 4 & $0.57142857$ \\
7 & 13 & 6 & $0.85714286$ \\
8 & 19 & 5 & $0.71428571$ \\
9 & 16 & 2 & $0.28571429$ \\
$\vdots$ & $\vdots$ & $\vdots$ & $\vdots$ \\
\hline
\end{tabular}
\end{center}
These illustrate three important properties of LCGs:
\begin{itemize}
    \item They are periodic. Because the integers $z^{[k]}$ are non-negative and bounded by $\eta$, the sequence of pseudo-random number must repeat in a continual loop of period $\leq \eta$.
    \item Their pseudo-random numbers always fall on a lattice. In our example, the lattice has a spacing between numbers that is a multiple of 1/7. More generally, Marsaglia (1968) demonstrates that n-tuples of consecutive numbers from LCGs always fall on sets of parallel planes in n-dimensional space.
    \item They may generate 0 as a pseudo-random number. Our definition of pseudo-random numbers requires that the numbers be in the open interval (0,1).
\end{itemize}
Periodicity is a property of all pseudorandom number generators. It is addressed by using a generator whose period exceeds the number of pseudorandom numbers required for an application. An LCGs period can be as high as $\eta$, but many have lower periods. We call a pseudorandom number generator whose period is the maximum possible for its form a full-period generator.
## Lattice structure and spectral test
Structural properties refer to the characteristics of the pattern formed by plotting the numbers. When these points are plotted in space, the form obtained is called the lattice. See below Figure \ref{fig:lattice} an example of lattice structure for 2 simple LCG generators:
\begin{figure}[H]
    \centering
    \includegraphics[scale=0.5]{figs/lattice.png}
    \caption{Sets of all points ($x^{[k]}, x^{[k+1]}$) generated by the LCGs: $z^{[k]}=89z^{[k-1]}$(mod 101) and $z^{[k]}=51z^{[k-1]}$(mod 101)}
    \label{fig:lattice}
\end{figure}
A good lattice structure means a large number of parallel planes. In theory, through judicious selection of the parameters $\eta$, $a$, and $c$, an LCG can be made to have a period of any order of magnitude. In the past, parameters were chosen so that
$$
a(\eta-1)+c<2^{53}
$$
This ensured that all calculations performed by an LCG could, with suitable coding, be performed in floating-point form without rounding on 32-bit computers. This restriction limited the maximal period $\eta$ that could be achieved with LCGs. Higher period LCGs could be implemented with multiple-precision arithmetic, but this was computationally inefficient. An alternative was to explore generalizations of LCGs that had high periods but could still be implemented with single-precision floating-point arithmetic on 32-bit computers. The most popular of these were multiple-recursive generators.
## Multiple recursive generator
A multiple recursive generator (MRG) of order 
$k$ is defined by the linear recurrence:
\begin{align}
    x_n&=(a_1x_{n-1}+\cdots+a_kx_{n-k})\ mod\ m\\
    u_n&=x_n/n
\end{align}
where $m$ and $k$ are positive integers, and each $a_i$ belongs to
$\mathbb{Z}_m = \{0, 1,\cdots, m-1\}$(see Grube 1973, Niederreiter 1992).

\textbf{The recurrence has maximal period length $m^k-1$, attained if and only if $m$ is prime and the characteristic polynomial $P(z)=z^k-a_1z^{k-1}-\cdots-a_k$ is primitive} (i.e., the powers of $z$, modulo $P(z)$ and m, run through all nonzero polynomials of degree less than k with coefficients in $Z_m$). The latter can be achieved most economically with only two nonzero coefficients, say $a_r$ and $a_k$ with $1\leq r<k$.The recurrence is generally easier to implement when these coefficients are small. However, a necessary condition for a good figure of merit with respect to the spectral test is that $\Sigma_{i=1}^ka_i^2$ be large (Grube 1973, L’Ecuyer 1997)\\
Table I, see Figure \ref{fig:table1} lists some values of m and k such that $m$, $(m-1)/ 2$, and $r=(m^k-1)/(m-1)$ are all prime. These values were found by random search, using a few months
of CPU time.
\begin{figure}[H]
    \centering
    \includegraphics[scale=0.8]{figs/table1.png}
    \caption{Table of $m$ and $k$ such that the full period condition is verified}
    \label{fig:table1}
\end{figure}
To reconcile these conflicting requirements, L’Ecuyer (1996)
proposed combined MRGs (CMRGs), where the components are carefully selected so that the combined generator has good structural properties, while each component remains easy to implement in an efficient manner.
## Combined MRGs (CMRGs)
### Notation
The CMRGs combine J copies of (3), that is:
\begin{equation}
    x_{j, n}=(a_{j,1}x_{j,n-1}+\cdots+a_{j,k}x_{j,n-k})\ mod\ m_j\\
\end{equation}
for $j=1,\cdots, J$ where the $m_j$ are distinct primes and the $j$th recurrence has order $k$ and period length $m_j^k-1$ Let $\delta_1, \cdots, \delta_J$ be arbitrary integers such that $\delta_j$ is relatively prime to $m_j$ for each $j$, and define:
\begin{align}
w_{n} &=\left(\sum_{j=1}^{J} \delta_{j} \frac{x_{j, n}}{m_{j}}\right) \bmod 1, \\
z_{n} &=\left(\sum_{j=1}^{J} \delta_{j} x_{j, n}\right) \bmod m_{1}, \\
\tilde{u}_{n} &=z_{n} / m_{1} .
\end{align}

The sequences $\{w_n, n\geq0\}$ and $\{\tilde{u}_n, n\geq0\}$ define two different CMRGs which have been studied by L’Ecuyer (1996). In summary, the CMRG (5)–(6) is exactly equivalent to an MRG as in (3) with modulus $m = m_1\cdots m_J$, and the set $Tt$ mentioned in the introduction is the intersection of a lattice with the unit hypercube. The points of Tt lie in successive parallel hyperplanes at a distance dt of each other. The other CMRG, defined by (7)–(8), is also approximately the same as the first one. In other words, these CMRGs are basically just special implementations of an MRG and they can be analyzed by applying the spectral
test to this MRG.\\
We use the figure of merit $M_T = min_{2\leq t\leq T} S_t$ for some
integer $T$, where $S_t = (\rho_tm^{k/t}d_t)^{-1}$ and $\rho_t$ is defined as follows. For $t\leq8$, $\rho_t$ is the $\gamma_t$ defined in Knuth (1981, p. 105), while for $t>8$, $\rho_t=exp(R(t)/t)$ where $R(t)$ is Rogers' bound on the density of sphere packings (see Conway and Sloane 1988, p. 88, and L’Ecuyer 1999). $S_t$ and $M_T$ are always between 0 and 1 and we seek generators with $M_T$ close to 1. An St close to 0 means that all the points of $T_t$ lie in equidistant parallel hyperplanes that are far apart, leaving thick slices of empty space in between. An $M_T$ close to 1 means that $T_t$ is evenly distributed over the unit hypercube, for all $t\leq T$.
### Constraints
+ (B) The product $a_{j,i}(m_j-1)$ is less than $2^{53}$
+ (C) The coefficient $a_{j,i}$ satisfies $a_{j,i}(m_j\ mod\ a_{j,i})<m_j$ 
If Condition (B) holds, the integer $a_{j,i}x_{ j,i}$ is always represented exactly in floating point on a 32-bit computer that supports the IEEE 754 floating-point arithmetic standard, with at least 53 bits of precision for the mantissa. The generator can then be implemented directly in floating point arithmetic, which is typically faster than an integer arithmetic implementation, although it uses twice the amount of memory. When Condition (C) is satisfied and each integer from $-m_j$ to $m_j$ fits into a computer word, each $x_{j,i}$ can be represented as an integer over a single computer word and the product $a_{j,i}x_{j,i}$ mod $m_j$ can be computed via the approximate factoring method described in Bratley et al. (1987) and L'Ecuyer and Coté (1991). This condition holds if and only if $a_{j,i}^2<m_j$ or $a_{j,i}=m_j/z$ for $z^2<m_j$
### CMRGs good parameters
In Table II, see Figure \ref{fig:table2}, l'Ecuyer gives the CMRGs with the best value of $M_{32}$ that he found for a few values of $(J, k, m_1,\cdots, m_J)$ and with certain constraints on the coefficients $a_{j,i}$ as indicated in the second column of the table. The coefficients not given in the table are equal to zero.

## Implementation and Numerical result
We implement here the third entry of Table II, see Figure \ref{fig:table2}, called MRG32k3a. This program implements
the combination (7)–(8), with $\delta_1 = -\delta_2 = 1$ and with the following slight modification: The normalization constant
is $1/(m_1 + 1)$ instead of $1/m_1$, and $z_n= 0$ is converted to
$z_n=m_1$. This modification is to make sure that the generator never returns exactly 0 or 1 (frequently, one takes the logarithm of $u$ or of $1-u$, where $u$ is the returned value, for example to generate exponential random variables).
\begin{verbatim}
    class MRG32k3a():
    """Class for generating random number based on MRG32k3a"""
    def __init__(self, seed_state:int=123)->None:
        self.a1 = [0, 1403580, -810728]
        self.m1 = 2**32 - 209

        self.a2 = [527612, 0, -1370589]
        self.m2 = 2**32 - 22853

        self.d = self.m1 + 1
        
        self.delta1 = 1
        self.delta2 = -1

        self.seed(seed_state)

    def seed(self, seed_state:int)->None:
        """set random seed

        Args:
            seed_state (int): seed value
        """
        assert 0 < seed_state < self.d, f"Out of Range 0 x < {self.d}"
        self.x1 = [seed_state, 0, 0]
        self.x2 = [seed_state, 0, 0]

    def randint(self)->int:
        """return random int in range 0..self.d

        Returns:
            int: random integer from 0 to self.d
        """
        x1i = sum(aa * xx for aa, xx in zip(self.a1, self.x1)) % self.m1
        x2i = sum(aa * xx for aa, xx in zip(self.a2, self.x2)) % self.m2
        self.x1 = [x1i] + self.x1[:2]
        self.x2 = [x2i] + self.x2[:2]

        z = (x1i*self.delta1 + x2i*self.delta2) % self.m1
        answer = self.m1 if z==0 else z
        return answer

    def uniform(self)->float:
        """return uniform random float between 0 and 1

        Returns:
            float: uniform random float between 0 and 1
        """
        return self.randint() / self.d
